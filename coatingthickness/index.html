<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Coating Thickness · NeXLMatrixCorrection.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js" type="text/javascript" defer="defer"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
</head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NeXLMatrixCorrection.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../example/">Example</a></li><li class="is-active"><a class="tocitem" href>Coating Thickness</a></li><li><a class="tocitem" href="../testagainstpap/">Compare To PAP</a></li><li><a class="tocitem" href="../testagainstheinrich/">Compare to Heinrich</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Coating Thickness</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Coating Thickness</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/usnistgov/NeXLMatrixCorrection.jl/blob/master/docs/src/coatingthickness.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h3 id="Measuring-the-Coating-Thickness"><a class="docs-heading-anchor" href="#Measuring-the-Coating-Thickness">Measuring the Coating Thickness</a><a id="Measuring-the-Coating-Thickness-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-the-Coating-Thickness" title="Permalink"></a></h3><p>Nicholas W. M. Ritchie, 13-Apr-2020; updated 11-May-2020</p><p>Often it is necessary to add a thin conductive coating to the surface of non-conductive samples to minimize the accumulation of electrical charges on or near the surface.  When these charges accumulate they can deflect and distort the beam and reduce the effective beam energy.</p><p>While the coatings are typically a thin as practical to produce the desired conductivity, the material in the coating can influence the transport of electrons and X-rays in the sample.  This is particularly true for soft X-rays like the K lines of Be, B, C, N, O and F or the L- or M-lines of similar energies.  The most common coating material is amorphous carbon deposited from a thread or hot filament although sputtered metal coatings like gold or gold-palladium are favored by some.</p><p>A common strategy for dealing with coatings has two parts. First, the thickness of the coating is measured using a oscillating quartz crystal <em>film thickness monitor</em>.  Second, the sample and the references are coated simultaneously to ensure similar coating thicknesses.  The thickness of the coating is then compensated in the matrix correction algorithm - usually as an additional absorption correction term.</p><p>An alternative strategy is to measure the thickness of the coating using the X-ray signal generated by the coating. This requires providing a standard spectrum for a coating element and measuring the k-ratio of this element in the sample and the other standards.  It is necessary that the measured coating element not be present in the material. For example, it is possible to measure a thin oxidization layer on aluminum using an oxygen standard like alumina (Al₂O₃) or magnesia (MgO).</p><p>While it is possible to measure the coating element using WDS, it is trivial using EDS.  This information is always available in the measured and standard spectra.  All that is necessary is to provide a bulk standard for the coating element in the fitting process.</p><p>A simple strategy for calculating the k-ratio of a ultra-thin coating on a substrate uses the bulk ϕ(ρz) correction for the coating element in the substrate material to estimate the effective k-ratio.  This requires knowledge of the composition of the substrate.  In the case of standards, this is available.  For unknowns, an estimated composition can be updated in the iteration algorithm.  A root-finding algorithm can then be used to solve for the thickness that produces the measured k-ratio.</p><h5 id="The-Calculation"><a class="docs-heading-anchor" href="#The-Calculation">The Calculation</a><a id="The-Calculation-1"></a><a class="docs-heading-anchor-permalink" href="#The-Calculation" title="Permalink"></a></h5><p>First, load &#39;NeXLSpectrum&#39; to read and fit the spectra and &#39;NeXLMatrixCorrection&#39; for k-ratio related calculations.</p><pre><code class="language-julia">using NeXLSpectrum
using NeXLMatrixCorrection
using DataFrames # To tabulate the k-ratios
using Gadfly  # To plot the fit residual</code></pre><p>Then read in the spectra - SiO₂ as the measured material, Si, Al₂O₃ and C as the references.</p><pre><code class="language-julia">path=joinpath(@__DIR__, &quot;spectra&quot;)
sio2=loadspectrum(joinpath(path,&quot;SiO2_StdC_15kV7p5nA130kHz_300s.msa&quot;))
si =loadspectrum(joinpath(path,&quot;Si_StdC_15kV7p5nA130kHz_132kHz24DT_100s.msa&quot;))
al2o3 = loadspectrum(joinpath(path,&quot;Al2O3_StdC_15kV7p5nA130kHz_300s.msa&quot;))
c = loadspectrum(joinpath(path,&quot;C_StdC_15kV7p5nA130kHz_48kHz9DT_100s.msa&quot;))
e0, toa = sameproperty([sio2,si,al2o3,c], :BeamEnergy), sameproperty([sio2,si,al2o3,c], :TakeOffAngle)
plot(sio2, si, al2o3, c, klms=[n&quot;Si&quot;, n&quot;Al&quot;, n&quot;O&quot;, n&quot;C&quot; ], xmax=2.5e3)</code></pre><p><img src="../figures/coatingthickness_2_1.svg" alt/></p><p>Build a detector model with details from the spectrum and an estimate of the resolution and low-level discriminator channel.</p><pre><code class="language-julia">det = BasicEDS(length(sio2), energy(1, sio2), channelwidth(1, sio2), 128.0, 120)
filt = buildfilter(det)</code></pre><pre><code class="language-none">NeXLSpectrum.VariableWidthFilter[NeXLSpectrum.BasicEDS(4096, E[ch] = -482.8
3378 + 5.003319999999974⋅ch, 128.0 eV @ Mn K-L3, 120, Dict{Shell,Element}(S
hell[L] =&gt; Element(Scandium),Shell[K] =&gt; Element(Beryllium),Shell[N] =&gt; Ele
ment(Plutonium),Shell[M] =&gt; Element(Barium)))]</code></pre><p>Create fitting filters for each element we require from the references.</p><pre><code class="language-julia">refdata = (
  ( al2o3, n&quot;O&quot;, mat&quot;Al2O3&quot; ),
  ( si, n&quot;Si&quot;, mat&quot;Si&quot; ),
  ( c, n&quot;C&quot;, mat&quot;C&quot; ),
)
frs = mapreduce(ref-&gt;filterreference(filt, ref...), append!, refdata)</code></pre><pre><code class="language-none">3-element Array{NeXLSpectrum.FilteredReference,1}:
 Reference[O K-L3 + 1 other]
 Reference[Si K-L3 + 2 others]
 Reference[C K-L2]</code></pre><p>Now with the fitting filters and the measured SiO₂ spectrum we can perform the fit of Si, O and C to SiO₂.</p><pre><code class="language-julia">res = fit(sio2, filt, frs)
display(plot(res))</code></pre><p><img src="../figures/coatingthickness_5_1.svg" alt/></p><pre><code class="language-julia">NeXLUncertainties.asa(DataFrame, kratios(res))</code></pre><pre><code class="language-none">3×12 DataFrame
│ Row │ Element │ Z     │ Lines              │ E0unk   │ E0std   │ θunk    
 │ θstd     │ Standard │ Cstd     │ ΔCstd   │ K         │ ΔK          │
│     │ String  │ Int64 │ Array{CharXRay,1}  │ Float64 │ Float64 │ Float64 
 │ Float64  │ String   │ Float64  │ Float64 │ Float64   │ Float64     │
├─────┼─────────┼───────┼────────────────────┼─────────┼─────────┼─────────
─┼──────────┼──────────┼──────────┼─────────┼───────────┼─────────────┤
│ 1   │ O       │ 8     │ O K-L3 + 1 other   │ 15000.0 │ 15000.0 │ 0.698132
 │ 0.698132 │ Al2O3    │ 0.470749 │ 0.0     │ 0.992173  │ 0.000449488 │
│ 2   │ C       │ 6     │ C K-L2             │ 15000.0 │ 15000.0 │ 0.698132
 │ 0.698132 │ C        │ 1.0      │ 0.0     │ 0.0124119 │ 3.91605e-5  │
│ 3   │ Si      │ 14    │ Si K-L3 + 2 others │ 15000.0 │ 15000.0 │ 0.698132
 │ 0.698132 │ Si       │ 1.0      │ 0.0     │ 0.430509  │ 0.000101609 │</code></pre><p>From the k-ratios, we can determine the mass-thickness of the carbon layer on the SiO₂ sample.</p><pre><code class="language-julia">k = value(findlabel(res, n&quot;C K-L2&quot;),res)
ρz = massthickness(XPP, mat&quot;SiO2&quot;, mat&quot;C&quot;, n&quot;C K-L2&quot;, sio2[:BeamEnergy], sio2[:TakeOffAngle], k)
print(&quot;The thickness is $(round(ρz*1.0e7/density(pure(n&quot;C&quot;)); sigdigits=3)) nm.&quot;)  # Convert g/cm² to nm of amorphous carbon (1.9 g/cm³)</code></pre><pre><code class="language-none">The thickness is 24.4 nm.</code></pre><pre><code class="language-julia">ρz = massthickness(CitZAF, mat&quot;SiO2&quot;, mat&quot;C&quot;, n&quot;C K-L2&quot;, sio2[:BeamEnergy], sio2[:TakeOffAngle], k)
print(&quot;The thickness is $(round(ρz*1.0e7/density(pure(n&quot;C&quot;)); sigdigits=3)) nm.&quot;)  # Convert g/cm² to nm of amorphous carbon (1.9 g/cm³)</code></pre><pre><code class="language-none">The thickness is 17.1 nm.</code></pre><p>Finally, we correct the measured k-ratios for Si and O to account for the carbon coating.</p><pre><code class="language-julia">krs = NeXLMatrixCorrection.correctkratios(kratios(res), mat&quot;C&quot;, ρz)
NeXLUncertainties.asa(DataFrame, krs)</code></pre><pre><code class="language-none">3×12 DataFrame
│ Row │ Element │ Z     │ Lines              │ E0unk   │ E0std   │ θunk    
 │ θstd     │ Standard │ Cstd     │ ΔCstd   │ K         │ ΔK          │
│     │ String  │ Int64 │ Array{CharXRay,1}  │ Float64 │ Float64 │ Float64 
 │ Float64  │ String   │ Float64  │ Float64 │ Float64   │ Float64     │
├─────┼─────────┼───────┼────────────────────┼─────────┼─────────┼─────────
─┼──────────┼──────────┼──────────┼─────────┼───────────┼─────────────┤
│ 1   │ O       │ 8     │ O K-L3 + 1 other   │ 15000.0 │ 15000.0 │ 0.698132
 │ 0.698132 │ Al2O3    │ 0.470749 │ 0.0     │ 1.05011   │ 0.000475736 │
│ 2   │ C       │ 6     │ C K-L2             │ 15000.0 │ 15000.0 │ 0.698132
 │ 0.698132 │ C        │ 1.0      │ 0.0     │ 0.0124119 │ 3.91605e-5  │
│ 3   │ Si      │ 14    │ Si K-L3 + 2 others │ 15000.0 │ 15000.0 │ 0.698132
 │ 0.698132 │ Si       │ 1.0      │ 0.0     │ 0.431379  │ 0.000101814 │</code></pre><p>Usually, the coating compensation is handled in the matrix correction algorithm through providing coating data.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example/">« Example</a><a class="docs-footer-nextpage" href="../testagainstpap/">Compare To PAP »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 28 July 2020 14:49">Tuesday 28 July 2020</span>. Using Julia version 1.5.0-rc2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
